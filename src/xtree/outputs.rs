use std::fs;
use std::io::Write;
use std::path::Path;

use chrono::Local;

use super::config::Config;
use super::ignore::IgnoreMatcher;
use super::render;
use super::theme::Theme;

pub fn print_json(root: &Path, cfg: &Config, ignore: &IgnoreMatcher) -> Result<(), String> {
    let node = render::json_node(root, cfg, ignore);
    let payload = serde_json::json!({"root": node});
    let txt = serde_json::to_string_pretty(&payload).map_err(|err| err.to_string())?;
    println!("{txt}");
    Ok(())
}

pub fn print_markdown(root: &Path, cfg: &Config, ignore: &IgnoreMatcher) -> Result<(), String> {
    println!("# ðŸ“‚ Directory Structure");
    println!();
    println!("**Path:** `{}`", root.display());
    println!();
    println!("**Generated:** {}", Local::now().to_rfc2822());
    println!();
    println!("---");
    println!();

    walk_md(root, root, cfg, ignore, "", 0)?;

    println!();
    println!("---");
    println!();
    println!("_Generated by dusk xtree (pure rust)_");
    Ok(())
}

fn walk_md(
    root: &Path,
    dir: &Path,
    cfg: &Config,
    ignore: &IgnoreMatcher,
    prefix: &str,
    depth: usize,
) -> Result<(), String> {
    if let Some(max_depth) = cfg.max_depth {
        if depth > max_depth {
            return Ok(());
        }
    }

    let mut items = fs::read_dir(dir)
        .map_err(|err| format!("failed reading {}: {err}", dir.display()))?
        .filter_map(Result::ok)
        .map(|e| e.path())
        .filter(|p| !ignore.is_ignored(p, p.is_dir(), cfg.show_hidden))
        .collect::<Vec<_>>();
    items.sort();

    for item in items {
        let mut line = render::md_line_for(&item);
        if !prefix.is_empty() {
            line = format!("{prefix}{line}");
        }
        println!("{line}");
        if item.is_dir() {
            walk_md(root, &item, cfg, ignore, &format!("{prefix}  "), depth + 1)?;
        }
    }

    let _ = root;
    Ok(())
}

pub fn print_prompt_dump(
    root: &Path,
    cfg: &Config,
    ignore: &IgnoreMatcher,
    theme: &Theme,
) -> Result<(), String> {
    let prompt_path = std::env::temp_dir().join("tree_prompt.txt");
    let mut tree_lines = Vec::new();
    let mut dirs = 0usize;
    let mut files = 0usize;
    let walker = walkdir::WalkDir::new(root)
        .into_iter()
        .filter_entry(|e| !ignore.is_ignored(e.path(), e.file_type().is_dir(), cfg.show_hidden));
    for entry in walker.filter_map(Result::ok) {
        let path = entry.path();
        if path == root {
            continue;
        }
        if path.is_dir() {
            dirs += 1;
        } else if path.is_file() {
            files += 1;
        }
        let rel = path.strip_prefix(root).ok().unwrap_or(path);
        tree_lines.push(format!("- {}", rel.display()));
    }

    let mut buf = Vec::new();
    writeln!(buf, "# Project Structure").map_err(|err| err.to_string())?;
    writeln!(buf).map_err(|err| err.to_string())?;
    writeln!(buf, "Generated on: {}", Local::now().to_rfc2822()).map_err(|err| err.to_string())?;
    writeln!(buf).map_err(|err| err.to_string())?;
    writeln!(buf, "```").map_err(|err| err.to_string())?;
    for line in &tree_lines {
        writeln!(buf, "{line}").map_err(|err| err.to_string())?;
    }
    writeln!(buf, "```").map_err(|err| err.to_string())?;
    writeln!(buf).map_err(|err| err.to_string())?;
    writeln!(buf, "## Project Metadata").map_err(|err| err.to_string())?;
    writeln!(buf).map_err(|err| err.to_string())?;
    writeln!(buf, "- **Total Directories**: {}", dirs).map_err(|err| err.to_string())?;
    writeln!(buf, "- **Total Files**: {}", files).map_err(|err| err.to_string())?;

    let out = String::from_utf8_lossy(&buf);
    print!("{out}");
    fs::write(&prompt_path, out.as_bytes()).map_err(|err| err.to_string())?;
    println!(
        "{}Prompt saved to {}{}",
        theme.header,
        prompt_path.display(),
        theme.reset
    );
    Ok(())
}
